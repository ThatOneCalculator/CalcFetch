#!/bin/sh

## OS/ENVIRONMENT INFO DETECTION

ostype="$(uname)"

if command -v getprop > /dev/null; then
	linuxtype=android
	host="$(getprop net.hostname)"
else
	. /etc/os-release
	case $ostype in
	Linux*) host="$(cat /proc/sys/kernel/hostname)";;
	*) host="host"
	esac
	linuxtype=none
fi
kernel="$(uname -r | cut -d'-'  -f1-1)"
case $ostype in
	"Linux"*)
		if [ -f /bedrock/etc/bedrock-release ]; then
			os="$(brl version)"
		elif [ $linuxtype = android ]; then
			os="Android $(getprop ro.build.version.release)"
		else
			os="${PRETTY_NAME}"
		fi
		shell=${SHELL##*/};;
	"Darwin"*)
		while IFS='<>' read -r _ _ line _; do
			case $line in
				ProductVersion)
					IFS='<>' read -r _ _ mac_version _
					break;;
			esac
		done < /System/Library/CoreServices/SystemVersion.plist
		os="macOS ${mac_version}";;
	*) os="Idk"
esac

## PACKAGE MANAGER AND PACKAGES DETECTION

has() { command -v "$1" 1>/dev/null 2>&1; }
mngr() {
	if [ -n "$manager" ]; then
		manager="${manager}, $1"
	else
		manager="$1"
	fi
}
pkgs() { packages="$((packages + $1))"; }
packages=0

has apk && {
	mngr apk
	pkgs "$(apk list --installed | wc -l)"
}
has apt && {
	mngr apt
	pkgs "$(dpkg-query -f '${binary:Package}\n' -W | wc -l)"
}
has brew && {
	mngr brew
	pkgs "$(printf '%s\n' "$(brew --cellar)"/* | wc -l)"
}
has cave && {
	mngr cave
	pkgs "$(cave show installed-slots | wc -l)"
}
has cpm && {
	mngr cpm
	pkgs "$(cpm C)"
}
has dnf && {
	mngr dnf
	pkgs "$(dnf list installed)"
}
has emerge && {
	mngr emerge
	pkgs "$(qlist -I | wc -l)"
}
has eopkg && {
	mngr eopkg
	pkgs "$(eopkg li | wc -l)"
}
has kiss && {
	mngr kiss
	pkgs "$(kiss list | wc -l)"
}
has nix-env && {
	mngr nix-env
	pkgs "$(nix-store -q --requisites /run/current-system/sw | wc -l)"
}
has pacman && {
	mngr pacman
	pkgs "$(pacman -Q | wc -l)"
}
has paru && {
	mngr paru
	pkgs "$(paru -Q | wc -l)"
}
has pkg && {
	mngr pkg
	pkgs "$(pkg info | wc -l)"
}
has pmm && {
	mngr pmm
	pkgs "$(/bedrock/libexec/pmm pacman pmm -Q 2>/dev/null | wc -l)"
}
has port && {
	mngr port
	pkgs "$(port installed | tot)"
}
has rpm && {
	mngr rpm
	pkgs "$(rpm -qa | wc -l)"
}
has xbps-query && {
	mngr xbps-query
	pkgs "$(xbps-query -l | wc -l)"
}
has yay && {
	mngr yay
	pkgs "$(yay -Q | wc -l)"
}
has yum && {
	mngr yum
	pkgs "$(yum list installed | wc -l)"
}
has zypper && {
	mngr zypper
	pkgs "$(zypper se | wc -l)"
}
has /usr/sin/slackpkg && {
	mngr slackpkg
	pkgs "$(ls /var/log/packages | wc -l)"
}
# If no package managers were found
test "$packages" -eq 0 && {
	manager=bin
	packages="$(tr ':' ' ' <<-EOF | xargs ls | wc -l
		$PATH
		EOF
	)"
}

## UPTIME DETECTION

case $ostype in
	"Linux")
		IFS=. read -r s _ < /proc/uptime;;
	*) 
		s=$(sysctl -n kern.boottime)
		s=${s#*=}
		s=${s%,*}
		s=$(($(date +%s) - s));;
esac
d="$((s / 60 / 60 / 24))"
h="$((s / 60 / 60 % 24))"
m="$((s / 60 % 60))"
# Plurals
[ "$d" -gt 1 ] && dp=s
[ "$h" -gt 1 ] && hp=s
[ "$m" -gt 1 ] && mp=s
[ "$s" -gt 1 ] && sp=s
# Hide empty fields.
[ "$d" = 0 ] && d=
[ "$h" = 0 ] && h=
[ "$m" = 0 ] && m=
[ "$m" != "" ] && s=
# Make the output of uptime smaller.
[ "$d" ] && uptime="$d day$dp, "
[ "$h" ] && uptime="$uptime$h hour$hp, "
[ "$m" ] && uptime="$uptime$m min$mp"
[ "$s" ] && uptime="$uptime$s sec$sp"
uptime=${uptime%, }

## RAM DETECTION

case $ostype in
	"Linux")
		while IFS=':k '  read -r key val _; do
			case $key in
				MemTotal)
					mem_used=$((mem_used + val))
					mem_full=$val;;
				Shmem) mem_used=$((mem_used + val));;
				MemFree|Buffers|Cached|SReclaimable) mem_used=$((mem_used - val));;
			esac
		done < /proc/meminfo
		mem_used=$((mem_used / 1024)) 
		mem_full=$((mem_full / 1024));;
	"Darwin"*)
		mem_full=$(($(sysctl -n hw.memsize) / 1024 / 1024))
		while IFS=:. read -r key val; do
			case $key in
				*' wired'*|*' active'*|*' occupied'*)
					mem_used=$((mem_used + ${val:-0}));;
			esac
			done <<-EOF
				$(vm_stat)
						EOF

			mem_used=$((mem_used * 4 / 1024));;
	*)
		mem_full="idk"
		mem_used="idk"
esac
memstat="${mem_used}/${mem_full} MB"
if which dc > /dev/null 2>&1; then
	mempercent="($(echo 100 ${mem_used} \* ${mem_full} / p | dc)%)"
fi
## DEFINE COLORS

bold='[1m'
black='[30m'
red='[31m'
green='[32m'
yellow='[33m'
blue='[34m'
magenta='[35m'
cyan='[36m'
white='[37m'
grey='[90m'
reset='[0m'

## USER VARIABLES -- YOU CAN CHANGE THESE

lc="${reset}${bold}${magenta}"  # labels
nc="${reset}${bold}${yellow}"   # user
hn="${reset}${bold}${blue}"     # hostname
ic="${reset}${green}"           # info
c0="${reset}${grey}"            # first color
c1="${reset}${white}"           # second color
c2="${reset}${yellow}"          # third color

## OUTPUT

cat <<EOF

${c0}      ___     ${nc}${USER}${red}@${reset}${hn}${host}${reset} 
${c0}     (${c1}.. ${c0}\    ${lc}ï…¼  ${ic}${os}${reset}
${c0}     (${c2}<> ${c0}|    ${lc}îˆº  ${ic}${kernel}${reset}
${c0}    /${c1}/  \\ ${c0}\\   ${lc}ï¡š  ${ic}${RAM}${memstat} ${mempercent}
${c0}   ( ${c1}|  | ${c0}/|  ${lc}ï£“  ${ic}${packages} (${manager})${reset}
${c2}  _${c0}/\\ ${c1}__)${c0}/${c2}_${c0})  ${lc}ï™µ  ${ic}${uptime}${reset}
${c2}  \/${c0}-____${c2}\/${reset}   ${lc}îˆ«  ${red}â–ˆâ–ˆâ–ˆ${green}â–ˆâ–ˆâ–ˆ${yellow}â–ˆâ–ˆâ–ˆ${blue}â–ˆâ–ˆâ–ˆ${magenta}â–ˆâ–ˆâ–ˆ${cyan}â–ˆâ–ˆâ–ˆ${reset}
EOF
